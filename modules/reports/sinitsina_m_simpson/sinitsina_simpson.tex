
\documentclass{report}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{indentfirst}


% Устанавливаю поля, отступы между абзацами, отступы в списке
\geometry{a4paper,top=2cm,bottom=3cm,left=2cm,right=1.5cm}
\setlength{\parskip}{0.5cm}
\setlist{nolistsep, itemsep=0.3cm,parsep=0pt}

% Мой стиль для листинга кода
\lstset{language=C++,
		basicstyle=\footnotesize,
		keywordstyle=\color{blue}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		commentstyle=\color{green}\ttfamily,
		morecomment=[l][\color{magenta}]{\#}, 
		tabsize=4,
		breaklines=true,
  		breakatwhitespace=true,
  		title=\lstname,       
}

% Замена [1] -> 1. в списке литературы
\makeatletter
\renewcommand\@biblabel[1]{#1.\hfil}
\makeatother

\begin{document}

% Титульный лист
\begin{titlepage}

\begin{center}
Министерство науки и высшего образования Российской Федерации
\end{center}

\begin{center}
Федеральное государственное автономное образовательное учреждение высшего образования \\
Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского
\end{center}

\begin{center}
Институт информационных технологий, математики и механики
\end{center}

\vspace{4em}

\begin{center}
\textbf{\LargeОтчет по лабораторной работе} \\
\end{center}
\begin{center}
\textbf{\Large«Вычисление многомерных интегралов методом Cимпсона»} \\
\end{center}

\vspace{5em}

\newbox{\lbox}
\savebox{\lbox}{\hbox{text}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{7,5cm}{
\hspace*{5cm}\hspace*{-5cm}\textbf{Выполнил:} \\ студент группы 381706-2 \\ Синицина Мария Сергеевна\\
\\
\hspace*{5cm}\hspace*{-5cm}\textbf{Проверил:}\\ доцент кафедры МОСТ, \\ кандидат технических наук \\ Сысоев Александр Владимирович
}

\vspace{\fill}

\begin{center} Нижний Новгород \\ 2020 \end{center}

\end{titlepage}
% Конец титульного листа

\setcounter{page}{2}

% Содержание
\tableofcontents
\newpage

% Введение
\section*{Введение}
\addcontentsline{toc}{section}{Введение}
В современном мире многие вычисления уже не производятся вручную – для этого существует специальная вычислительная техника, ведь проводимые эксперименты становятся сложнее: объём выборки и трудоёмкость алгоритмов уже не позволяют производить расчёты на бумаге – такой объём работы может оказаться просто не под силу даже группе людей, к тому же в таком случае нельзя гарантировать правильность подсчётов наверняка, так как имеет место быть человеческих фактор. Для больших объёмов вычислений уже давно используют специальную технику и имеющиеся алгоритмы, однако даже при использовании производящих подсчёты устройств может пройти достаточно много времени до получения результата. А если это не научный эксперимент, результаты которого в дальнейшем станут почвой для размышлений больших умов, а программа, работающая в реальном времени, то вопрос скорости получения ответа встаёт более остро. Здесь нам на помощь приходит понятие оптимизации.
\par Оптимизация — процесс максимизации выгодных характеристик, соотношений (например, оптимизация производственных процессов и производства), и минимизации расходов.
\par В нашем случае речь идёт о минимизации времени вычислений путём распараллеливания программы на некоторое количество процессов, так как время в контексте поставленной задачи – самый ценный ресурс.
\par Реализация метода Симпсона включает в себя рекурсивный алгоритм, необходимый для осуществления погружения на уровни при вычислении многомерного интеграла, являющийся частью системы распараллеливания интеграла первого уровня. В данной работе будет реализован как последовательный алгоритм вычисления итеграла методом Симпсона, так и его параллельные варианты, написанные при помощи технологий OpenMP, TBB и std::threads. 
\newpage
% Конец введения

% Постановка задачи
\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}

Основной задачей проекта является изучение метода Симпсона для решения множественных интегралов различной сложности, а также разработка программы, решающей подобные определённые интегралы.

Выделим следующие подзадачи:
\begin{enumerate} 
\itemРеализация последовательного алгоритма метода Симпсона для получения численного решения множественного определённого интеграла
\itemНаписание параллельного алгоритма метода Симпсона, используя технологию параллельного программирования OpenMP.
\itemНаписание параллельного алгоритма метода Симпсона, используя технологию параллельного программирования TBB.
\itemНаписание параллельного алгоритма метода Симпсона, используя технологию параллельного программирования std::threads.
\itemТестирование работоспособности написанных алгоритмов посредствам тестов, написанных с использованием Google C++ Testing Framework
\itemПроведение анализа и сравнение времени работы последовательного и параллельных алгоритмов, осуществление оценки программы на основе произведённых экспериментов с помощью расчёта ускорения.
\end{enumerate} 

\newpage
% Конец постановки задачи

% Описание алгоритма
\section*{Описание алгоритма}
\addcontentsline{toc}{section}{Описание алгоритма}
Суть метода Симпсона заключается в приближении подынтегральной функции на отрезке $[a; b]$ интерполяционным многочленом второй степени $p2(x)$, то есть приближение графика функции на отрезке параболой.

\parПусть функция $y = f(x)$ непрерывна на отрезке $[a; b]$ и нам требуется вычислить определенный интеграл $\int_{a}^{b} f(x)dx$ 

\parРазобьем отрезок $[a; b]$ на n элементарных отрезков $[x_{2i-2}; x_{2i}]$, $ i = 1, 2, \ldots, n$ длины $ 2h = (b - a)/n$ точками $ a = x_0 < x_2 < … < x_{2n-2} < x_n = b $.

\parПусть точки $x_{2n-1}$, $ i = 1, 2, \ldots, n$ являются серединами отрезков $[x_{2i-2}; x_{2i}]$, $ i = 1, 2, \ldots, n$ соответственно.
В этом случае все "узлы" определяются из равенства $x_i = a + ih$, $i = 0, 1, 2,\ldots, n$

\parНа каждом интервале $[x_{2i-2}; x_{2i}]$, $i = 1, 2, \ldots, n$ подынтегральная функция приближается квадратичной параболой $y = a_i x^2 + b_i x + c_i$ , проходящей через точки $(x_{2i-2};f(x_{2i-2}))$, $(x_{2i-1};f(x_{2i-1}))$, $(x_{2i};f(x_{2i}))$. Отсюда и название метода - метод парабол.

\parЭто делается для того, чтобы в качестве приближенного значения определенного интеграла $\int_{x_{2i-2}}^{x_{2i}}f(x)dx$ взять $\int_{x_{2i-2}}^{x_{2i}}(a_i x^2 + b_i x + c_i) dx$ можем вычислить по формуле Ньютона-Лейбница. В этом и заключается суть метода парабол.

\newpage
% Конец описания

% Схема распараллеливания
\section*{Схема распараллеливания}
\addcontentsline{toc}{section}{Схема распараллеливания}

В лабораторной работе осуществляется распараллеливание многомерного интеграла. В начале имеется область интегрирования, заданная отрезками $[a_i; b_i]$, $i = 1,\ldots, n$, количество которых совпадает с количеством интегралов n в многомерном интеграле. Также в примере изначально задаётся число разбиений данных отрезков; эти данные в алгоритм передаются в алгоритм виде литеры и не имеют отдельной переменной для хранения, так как для каждого примера имеется своё индивидуальное значение.
\par Самая дорогостоящая операция в данном алгоритме - вычисление значения функции в узле сетки. Поэтому все алгоритмы распараллеливания нацелены на оптимизацию данной операции.
\subsection*{OpenMP}
\addcontentsline{toc}{subsection}{OpenMP}
\par Для ускорения операции вычисления значения функции в узле сетки с использованием технологии OpenMP воспользуемся директивой для распределения вычислений в параллельной области for, которая отвечает за распараллеливание циклов.
\par В качестве ее параметра используем параметр firstprivate, позволяющий создавать локальные переменные потоков, которые перед использованием инициализируются значениями исходных переменных.
\parЗавершение директивы по умолчанию является синхронным.


\subsection*{TBB}
\addcontentsline{toc}{subsection}{TBB}
\par Библиотека TBB дает возможность реализовать параллельную версию вычислений с заранее определенным числом итераций с использованием цикла for. Для этого библиотека предоставляет шаблонную функцию \verb|tbb::parallel_for|.
\parПервый параметр функции \verb|parallel_for| представляет итерационное пространство – класс специального вида, задающий количество итераций цикла.
В данной задаче используем одномерное итерационное пространство \\ \verb|tbb::blocked_range|, в котором задаем диапазон в виде полуинтервала [begin, end), означающих число узлов сетки от 0 до N. Последний параметр\\ \verb|tbb::blocked_range|, задающий размер порции вычислений, берем константным, его размер варьируется в зависимости от величины входных данных.

\subsection*{std::threads}
\addcontentsline{toc}{subsection}{Std::threads}
Для ускорения операции вычисления значения функции в узле сетки с использованием технологии std::threads разделим общее число узлов между потоками. Каждый из потоков выполнит свою часть задания, после чего при помощи join будет произведена синхронизация данных.

\newpage
% Конец схемы распараллеливания



% Описание программной реализации
\section*{Описание программной реализации}
\addcontentsline{toc}{section}{Описание программной реализации}
Каждая реализация раcположена в отдельной программе, каждая из которых содержит заголовочный файл \verb|simpson.h|, в котором объявлены функции:
\par\verb|double Simpson_Integr_par(double(*func)(std::vector<double>),| \\\verb|std::vector <double> x, std::vector <double> y, int n, size_t dimension,|\\\verb|std::vector<double> lim)|— вычисление многомерного интеграла методом Cимпcона, параллельная версия

\par\verb|double Simpson_Integr_seq(double(*func)(std::vector<double>),| \\\verb|std::vector <double> x, std::vector <double> y, int n, size_t dimension,|\\\verb|std::vector<double> lim)|— вычисление многомерного интеграла методом Симпсона, последовательная версия
\parФайла \verb|simpson.cpp| в котором содержится реализация данных функций и файла \verb|main.cpp| в котором содержаться тесты для проверки корректности программы. 

\newpage
% Конец описания программной реализации

% Подтверждение корректности
\section*{Подтверждение корректности}
\addcontentsline{toc}{section}{Подтверждение корректности}
Основным инструментом работоспособности программы являются тесты, разработанные при использовании Google C++ Testing Framework. Правильность получаемых результатов проверяется на пяти различных функциях разной сложности.
\parТесты:
\begin{enumerate} 
\item \verb|Multiple_Simpson_Integraion_TBB, Test_1_Integral_with_1_dimension_f1|	- взятие интеграла от функции $(y=1 / (1 + x))$ по области $x\in[0,1]$, c числом разбиений равным 100.
\item\verb|Multiple_Simpson_Integraion_TBB, Test_2_Integral_with_1_dimension_f2|	- взятие интеграла от функции $(y=sin(x^2))$ по области $x\in[0,1.6]$, c числом разбиений равным 100.
\item\verb|Multiple_Simpson_Integraion_TBB, Test_3_Integral_with_1_dimension_f3|	- взятие интеграла от функции $(y = x / ( x^4 + 4))$ по области $x\in[0,5]$, c числом разбиений равным 100.
\item\verb|Multiple_Simpson_Integraion_TBB, Test_4_Integral_with_1_dimension_f4|	- взятие интеграла от функции $(y=x)$ по области $x\in[0,1]$, c числом разбиений равным 100.
\item\verb|Multiple_Simpson_Integraion_TBB, Test_5_Integral_with_2_dimension_f5|	- взятие интеграла от функции $(z= x+2*sin(y))$ по области $x\in[0,0.2]$, $y\in[0,3.14159]$, c числом разбиений равным 100.
\end{enumerate} 
Все тесты проходят проверку, что является доказательством корректной работы программы.
\newpage
% Конец подтверждения корректности

% Эксперименты
\section*{Эксперименты}
\addcontentsline{toc}{section}{Эксперименты}
Конфигурация системы:
\begin{itemize}
\item Процессор: AMD Ryzen 5 3500U ;
\item Оперативная память: 16 Gb;
\item ОС: Microsoft Windows 10;
\end{itemize}

\par  Задана фунция $f(x)=sin(x^2)$ на интервале $[0;5]$ с числом шагов $ n=100000000$ и погрешностью вычислений $error = 0.000001$. 
\par Зафиксировано среднее время работы программы на 50 запусков. Получены следующие результаты работы данных технологий на различном числе потоков:

\begin{table}[!h]
\caption{Резултаты вычислительных экспериментов}
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
\multirow{3}{*}
	{\begin{tabular}[c]{@{}c@{}}Кол-во\\ потоков\end{tabular}} & 
\multirow{2}{*}
	{\begin{tabular}[c]{@{}c@{}}Последовательный\\ алгоритм\end{tabular}} & 
\multicolumn{6}{c|}
	{Параллельный алгоритм}	\\ 
	\cline{3-8} & & 
	\multicolumn{2}{c|}{OpenMP} & 
	\multicolumn{2}{c|}{TBB} & 
	\multicolumn{2}{c|}{std::threads} 
	\\ \cline{2-8}
	& t, с	    & t, с & speedup		& t, с & speedup		& t, с & speedup		\\ \hline
2   & 17.87     & 13.24 & 1.34       	& 14.93 & 1.19        	& 10.95 & 1.63           \\ \hline
4   & 17.87     & 9.05 & 1.97       	& 14.52 & 1.23         	& 8.18  & 2.18          \\ \hline
6   & 17.87     & 8.13 & 2.19       	& 12.45 & 1.43         	& 7.19  & 2.48          \\ \hline
8   & 17.87     & 7.4 & 2.41       	& 9.08 & 1.96         	& 6.37  & 2.81          \\ \hline
\end{tabular}
\end{table}
\par Лучший результат на любом числе потоков показала технология std::threads. Это объясняется отсутствием планировщика задач и собственной реализацией под конкретную задачу. На 8 потоках данная программа имеет ускорение почти в три раза, так как синхронизация данных происходит всего один раз после того, как все потоки выполнили за один проход свою часть задания. 
\parПрограмма с технологией OpenMP при таких же условиях имеет хорошее ускорение почти в два с половиной раза, при этом ее релизация гораздо проще и универсальнее. 
\parТехнология TBB показала самое маленькое ускорение на 8 потоках. Это объясняется работой планировщика и размером порции вычислений, который в данной задаче был указан константно со значением 100000. Этот размер брался из соображений, что каждый поток должен выполнить примерно равную работу. При этом синхронизация данных заняла большую часть времени, из-за которой и получилось такое маленькое, в сранении с std::threads и OpenMP, ускорение.

\newpage
% Конец результатов экспериментов

% Заключение
\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}


\parВ ходе работы были реализованы последовательная и параллельные версии алгоритма метода Симпсона для вычисления многомерных интегралов. А также выполнены все поставленные подзадачи.
\parПроведен ряд тестов, доказывающий корректность реализованной программы. Корректность получаемых результатов проверяется на заданных примерах с помощью тестов, написанных при использовании Google C++ Testing Framework. 

\parОсновным результатом работы программы стали данные, подтверждающие превосходство параллельных вычислений, а также зависимость скорости работы программы от количества потоков.

\parТакже были проанализированны три технологии параллельного программирования. Была произведена оценка этих технологий в применении к реализации метода Симпсона на основе полученных данных и расчетов ускорений при фиксированном числе потоков. Таблица 1 наглядно демонстрирует увеличение значения ускорения с увеличением числа процессов.

\parВремя работы программы также зависит от сложности заданной функции, количества разбиений и размерности интегралов. Однако анализ работы проводился при константных перечисленных параметров с изменением лишь числа потоков.

\newpage
% Конец заключения

% Список литературы
\begin{thebibliography}{1}
\addcontentsline{toc}{section}{Список литературы}

\bibitem{Gergel} Гергель В.П., Стронгин Р.Г. Основы параллельных вычислений для многопроцессорных вычислительных систем. Учебное пособие – Нижний Новгород: Изд-во ННГУ им. Н.И. Лобачевского, 2003. 184 с. ISBN 5-85746-602-4. 

\bibitem{Wiki1} Wikipedia: the free encyclopedia [Электронный ресурс] // URL: https://ru.wikipedia.org/wiki/\verb|Формула_Симпсона| (дата обращения: 19.03.2020)

\end{thebibliography}
\newpage
% Конец списка литературы

% Приложение
\section*{Приложение}
\addcontentsline{toc}{section}{Приложение}
Код:
\lstinputlisting[language=C++, caption=Последовательная версия. Заголовочный файл]{../../../../modules/task_1/sinitsina_m_simpson/simpson.h}
\lstinputlisting[language=C++, caption=Последовательная версия. Cpp файл]{../../../../modules/task_1/sinitsina_m_simpson/simpson.cpp}
\lstinputlisting[language=C++, caption=Последовательная версия. Тесты]{../../../../modules/task_1/sinitsina_m_simpson/main.cpp}

\lstinputlisting[language=C++, caption=OpenMP версия. Заголовочный файл]{../../../../modules/task_2/sinitsina_m_simpson/simpson.h}
\lstinputlisting[language=C++, caption=OpenMP версия. Cpp файл]{../../../../modules/task_2/sinitsina_m_simpson/simpson.cpp}
\lstinputlisting[language=C++, caption=OpenMP версия. Тесты]{../../../../modules/task_2/sinitsina_m_simpson/main.cpp}

\lstinputlisting[language=C++, caption=TBB версия. Заголовочный файл]{../../../../modules/task_3/sinitsina_m_simpson/simpson.h}
\lstinputlisting[language=C++, caption=TBB версия. Cpp файл]{../../../../modules/task_3/sinitsina_m_simpson/simpson.cpp}
\lstinputlisting[language=C++, caption=TBB версия. Тесты]{../../../../modules/task_3/sinitsina_m_simpson/main.cpp}

\lstinputlisting[language=C++, caption=std::thread версия. Заголовочный файл]{../../../../modules/task_4/sinitsina_m_simpson/simpson.h}
\lstinputlisting[language=C++, caption=std::thread версия. Cpp файл]{../../../../modules/task_4/sinitsina_m_simpson/simpson.cpp}
\lstinputlisting[language=C++, caption=std::thread версия. Тесты]{../../../../modules/task_4/sinitsina_m_simpson/main.cpp}


\end{document}