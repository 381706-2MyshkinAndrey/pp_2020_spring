\documentclass{report}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{caption}

\geometry{a4paper,top=2cm,bottom=3cm,left=2cm,right=1.5cm}
\setlength{\parskip}{0.5cm}
\setlist{nolistsep, itemsep=0.3cm,parsep=0pt}

\lstset{language=C++,
		basicstyle=\footnotesize,
		keywordstyle=\color{blue}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		commentstyle=\color{green}\ttfamily,
		morecomment=[l][\color{magenta}]{\#}, 
		tabsize=4,
		breaklines=true,
  		breakatwhitespace=true,
  		title=\lstname,       
}

\makeatletter
\renewcommand\@biblabel[1]{#1.\hfil}
\makeatother

\begin{document}

\begin{titlepage}

\begin{center}
Министерство науки и высшего образования Российской Федерации
\end{center}

\begin{center}
Федеральное государственное автономное образовательное учреждение высшего образования \\
Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского
\end{center}

\begin{center}
Институт информационных технологий, математики и механики
\end{center}

\vspace{4em}

\begin{center}
\textbf{\LargeОтчет по лабораторной работе} \\
\end{center}
\begin{center}
\textbf{\Large«Сортировка Шелла с четно-нечетным слиянием Бэтчера»} \\
\end{center}

\vspace{4em}

\newbox{\lbox}
\savebox{\lbox}{\hbox{text}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{7cm}{
\hspace*{5cm}\hspace*{-5cm}\textbf{Выполнил:} \\ студент группы 381706-2 \\ Банденков Д. В.\\
\\
\hspace*{5cm}\hspace*{-5cm}\textbf{Проверил:}\\ доцент кафедры МОСТ, \\ кандидат технических наук \\ Сысоев А. В.
}

\vspace{\fill}

\begin{center} Нижний Новгород \\ 2020 \end{center}

\end{titlepage}

\setcounter{page}{2}

\tableofcontents
\newpage

\section*{Введение}
\addcontentsline{toc}{section}{Введение}
Сортировка – одна из наиболее распространенных операций обработки данных. Она используется в множестве задач в разных областях. На больших объемах данных время работы, даже наиболее оптимальных методов сортировки, занимает достаточно много времени. Для достижения большей производительности необходимо разбить исходные данные на массивы меньшего размера, произвести упорядочивание подмассивов параллельно, а в конце слить их в один массив. Это значительно ускоряет сортировку, однако возникает проблема корректного слияния полученных фрагментов. Использование четно-нечетного слияния Бэтчера решает эту проблему.
\par Для упорядочивания массивов меньшего размера в данной работе используется алгоритм сортировки опубликованный в 1959 году американским ученым Дональдом Шеллом, который впоследствии получил его имя – «Сортировка Шелла». Идея метода Шелла состоит в сравнении элементов, стоящих не только рядом, но и на определённом расстоянии друг от друга. Худшее время данной сортировки O($n^2$), лучшее время O($nlog^2n$).
\par Целью данной работы является реализация сортировки Шелла с четно-нечетным слиянием Бэтчера с использованием различных технологий для выполнения параллельных вычислений.
\newpage

\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}
Для выполнения цели работы были поставлены следующие задачи:
\begin{itemize}
\item Реализовать последовательный алгоритм сортировки Шелла с четно-нечетным слиянием Бэтчера.
\item Реализовать параллельный алгоритм, с использованием OpenMP.
\item Реализовать параллельный алгоритм, с использованием TBB.
\item Реализовать параллельный алгоритм, с использованием std::thread.
\item Провести вычислительные эксперименты.
\item Сравнить время работы каждой реализации и проанализировать результаты.
\end{itemize}

\newpage

\section*{Описание алгоритмов}
\addcontentsline{toc}{section}{Описание алгоритмов}
Оснавная идея сортировки Шелла заключается в сравнение разделенных на группы элементов последовательности, находящихся друг от друга на некотором расстоянии. Изначально это расстояние равно $d$ или $\frac{N}{2}$, где $N$ — общее число элементов. На первом шаге каждая группа включает в себя два элемента расположенных друг от друга на расстоянии $\frac{N}{2}$; они сравниваются между собой, и, в случае необходимости, меняются местами. На последующих шагах также происходят проверка и обмен, но расстояние $d$ сокращается на $\frac{d}{2}$, и количество групп, соответственно, уменьшается. Постепенно расстояние между элементами уменьшается, и на $d=1$ проход по массиву происходит в последний раз.
\par Идея четно-нечетного слияния Бэтчера заключается в том, что два упорядоченных массива, которые необходимо слить, разделяются на четные и нечетные элементы. Далее выполняется слияние отдельно четных и нечетных элементов массивов. А после слияние четного и нечетного подмассивов в один. Чтобы массив стал окончательно отсортированным, достаточно сравнить пары элементов, стоящие на нечетной и четной позициях.
\newpage

\section*{Описание схемы распараллеливания}
\addcontentsline{toc}{section}{Описание схемы распараллеливания}
Общая схема работы параллельного алгоритма:
\begin{enumerate}
\item Исходный массив размера $size$, который нужно отсортировать, в зависимости от числа потоков $n$, заданных пользователем разбивается на  подмассивы размера $\frac{size}{n}$.
\item Каждый из потоков выполняет алгоритм сортировки Шелла для своего подмассива.
\item Отсортированные части сливаются в один массив при помощи алгоритма четно-нечетного слияния Бэтчера.
\end{enumerate}
\newpage

\section*{Описание программной реализации}
\addcontentsline{toc}{section}{Описание программной реализации}
\subsection*{OpenMP}
\addcontentsline{toc}{subsection}{OpenMP}
\par Директива \verb|#pragma omp| \verb|parallel| является основной директивой OpenMP. 
\par Так как по общей схеме требуется параллельно выполнить сортировку Шелла, воспользуемся специальной директивой OpenMP \verb|for|, которая позволяет распараллеливать циклы. При достижении основным потоком \verb|parallel|, создается команда \verb|team| потоков. Основной поток входит в команду под номером 0. Код данной области становится потоковой функцией и назначается потокам для параллельного вычисления. В конце области потоки автоматически синхронизируются и последующие вычисления продолжает выполнять только основной \verb|master thread| поток.
\par После параллельной сортировки подмассивов, полученные части соединяются в один массив при помощи алгоритма четно-нечетного слияния Бэтчера.

\subsection*{TBB}
\addcontentsline{toc}{subsection}{TBB}
Для использования возможностей TBB по распараллеливанию вычислений необходимо инициализировать экземпляр класса \verb|tbb::task_scheduler_init|. Этот класс предназначен для создания потоков и внутренних структур, необходимых планировщику для работы. Исходя из общей схемы, нужно на нескольких потоках выполнить сортировку Шелла. Для распараллеливания циклов библиотека предоставляет шаблонную функцию \verb|tbb::parallel_for|.
\par Первый параметр функции  \verb|tbb::parallel_for| представляет итерационное пространство \verb|tbb::blocked_range|, и задает диапазон в виде полуинтервала [begin, end), где begin - 0 (начало двумерного вектора, состоящего из частей исходного массива), end - \verb|vec.size()| (конец двумерного вектора).
\par Второй параметр функции – функтор, класс, реализующий вычисления цикла через метод \verb|body::operator()|.
\par После параллельной сортировки подмассивов, полученные части соединяются в один массив при помощи алгоритма четно-нечетного слияния Бэтчера.

\subsection*{std::thread}
\addcontentsline{toc}{subsection}{std::thread}
Для работы с std::thread необходимо "вручную" создавать объект потока \verb|std::thread|. 
\par После этого в цикле создаем потоки, конструктор в качестве обязательных параметров принимает: указатель на функцию, которую будет исполнять(в данном случае сортировка Шелла), и параметры этой функции.
\par Чтобы дождаться завершения вычислений потоков, мастер-поток последовательно вызывает метод \verb|join()| для каждого потока. 
\par После параллельной сортировки подмассивов, полученные части соединяются в один массив при помощи алгоритма четно-нечетного слияния Бэтчера.
\newpage

\section*{Подтверждение корректности}
\addcontentsline{toc}{section}{Подтверждение корректности}
Для подтверждения корректности в программе реализован набор тестов, разработанных при помощи библиотеки для модульного тестирования Google C++ Testing Framework. Результат работы последователной и параллельной сортировки сравниваются с \verb|std::sort()| определенной в библиотеке stl.
\par Благодаря облачным сервисам Continuous Integration(Travis CI, AppVeyor), написанная программа постоянно проверяется на корректность. Успешное прохождение всех тестов является подтвержением корректной работы программы. 

\newpage

\section*{Результаты экспериментов}
\addcontentsline{toc}{section}{Результаты экспериментов}
Конфигурация системы:
\begin{itemize}
\item Процессор: AMD FX(tm)-6300 Six-Core Processor 3.50 GHz
\item Число ядер: 6
\item Оперативная память: 16 Гб (DDR3), 2000 MHz;
\item ОС: Windows 10 Pro
\end{itemize}

\par Эксперименты проводяться на массиве размером 200 000 000. 
\par Результаты проведенных экспериментов представлены в Таблице 1.

\begin{table}[!h]
\caption{Резултаты экспериментов}
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
\multirow{3}{*}
	{\begin{tabular}[c]{@{}c@{}}Кол-во\\ потоков\end{tabular}} & 
\multirow{2}{*}
	{\begin{tabular}[c]{@{}c@{}}Последовательный\\ алгоритм\end{tabular}} & 
\multicolumn{6}{c|}
	{Параллельный алгоритм}	\\ 
	\cline{3-8} & & 
	\multicolumn{2}{c|}{OpenMP} & 
	\multicolumn{2}{c|}{TBB} & 
	\multicolumn{2}{c|}{std::thread} 
	\\ \cline{2-8}
	& t, с	    & t, с & speedup		& t, с & speedup		& t, с & speedup		\\ \hline
2   & 43.51     & 26.85 & 1.62       	& 26.79 & 1.62        	& 26.61 & 1.64           \\ \hline
4   & 43.51     & 18.94 & 2.30       	& 18.77 & 2.32         	& 17.90  & 2.43          \\ \hline
6   & 43.51     & 17.51 & 2.48       	& 17.39 & 2.50        	& 16.40  & 2.65          \\ \hline
\end{tabular}
\end{table}

\par По полученным данным видно, что параллельный алгоритм с использованием технологии std::thread имеет самое большое ускорение. Следовательно, при данной реализации, из-за отсутствия у std::thread планировщика задач, который расходует время на распредление задач между потоками, использование std::thread выгоднее чем TBB. Стоит отметить, что эксперименты проводились на процессоре AMD, и так как библиотека TBB была разработанна компанией Intel, скорее всего, ее производительность была бы выше, если проводить тестирование на процессоре Intel. 
\newpage

\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
В ходе выполнения данных лабораторных работ была подробно изучена сортировка Шелла с четно-нечетным слиянием Бэтчера. Была реализованы последовательная и параллельные версии алгоритма с использованием технологий: OpenMP, TBB, std::thread.
\par Для подтверждающие корректность работы программы были разработаны тесты, при помощи библиотеки для модульного тестирования Google C++ Testing Framework.
\par И в результате, были проведены эксперименты, подтверждающие эффективность параллельных версий алгоритмов. Следовательно, все поставленные задачи были выполнены.
\newpage

\begin{thebibliography}{1}
\addcontentsline{toc}{section}{Список литературы}
\bibitem{Sysoev} Сысоев А.В., Мееров И.Б., Свистунов А.Н., Курылев А.Л., Сенин А.В., Шишков А.В., Корняков К.В., Сиднев А.А. «Параллельное программирование в системах с общей памятью. Инструментальная поддержка». Учебно-методические материалы по программе повышения квалификации «Технологии высокопроизводительных вычислений для обеспечения учебного процесса и научных исследований». Нижний Новгород, 2007, 110 с. 
\bibitem{Barkalov} Баркалов К.А. Методы параллельных вычислений. Н. Новгород: Изд-во Нижегородского госуниверситета им. Н.И. Лобачевского, 2011
\bibitem{Wiki1} Wikipedia: the free encyclopedia [Электронный ресурс] // URL: https://en.wikipedia.org/wiki/Shellsort (дата обращения: 23.03.2020)
\bibitem{Wiki1} Wikipedia: the free encyclopedia [Электронный ресурс] // URL: https://en.wikipedia.org/wiki/\verb|Batcher_odd-even_mergesort| (дата обращения: 23.03.2020)
\end{thebibliography}
\newpage

\section*{Приложение}
\addcontentsline{toc}{section}{Приложение}
\centerline{\bfseries Исходный код.} 

\lstinputlisting[language=C++, caption=Последовательная версия. Заголовочный файл]{../../../../modules/task_1/bandenkov_d_shell_batcher_sort/shell_batcher.h}
\lstinputlisting[language=C++, caption=Последовательная версия. Cpp файл]{../../../../modules/task_1/bandenkov_d_shell_batcher_sort/shell_batcher.cpp}
\lstinputlisting[language=C++, caption=Последовательная версия. Тесты]{../../../../modules/task_1/bandenkov_d_shell_batcher_sort/main.cpp}

\lstinputlisting[language=C++, caption=OpenMP версия. Заголовочный файл]{../../../../modules/task_2/bandenkov_d_shell_bancher/shell_batcher.h}
\lstinputlisting[language=C++, caption=OpenMP версия. Cpp файл]{../../../../modules/task_2/bandenkov_d_shell_bancher/shell_batcher.cpp}
\lstinputlisting[language=C++, caption=OpenMP версия. Тесты]{../../../../modules/task_2/bandenkov_d_shell_bancher/main.cpp}

\lstinputlisting[language=C++, caption=TBB версия. Заголовочный файл]{../../../../modules/task_3/bandenkov_d_shell_bancher/shell_batcher.h}
\lstinputlisting[language=C++, caption=TBB версия. Cpp файл]{../../../../modules/task_3/bandenkov_d_shell_bancher/shell_batcher.cpp}
\lstinputlisting[language=C++, caption=TBB версия. Тесты]{../../../../modules/task_3/bandenkov_d_shell_bancher/main.cpp}

\lstinputlisting[language=C++, caption=std::thread версия. Заголовочный файл]{../../../../modules/task_4/bandenkov_d_shell_bancher/shell_batcher.h}
\lstinputlisting[language=C++, caption=std::thread версия. Cpp файл]{../../../../modules/task_4/bandenkov_d_shell_bancher/shell_batcher.cpp}
\lstinputlisting[language=C++, caption=std::thread версия. Тесты]{../../../../modules/task_4/bandenkov_d_shell_bancher/main.cpp}



\end{document}