\documentclass{report}

\usepackage[english, russian]{babel}
\usepackage{geometry}
\usepackage{listings}
\usepackage[T2A]{fontenc}
\usepackage[14pt]{extsizes}
\usepackage{verbatim}
\usepackage{multirow}
\usepackage{color}
\usepackage{graphicx}
\usepackage[titles]{tocloft}
\usepackage[hyphens]{url}


\geometry{a4paper,top=2cm,bottom=2cm,left=2cm,right=1.5cm}
\setlength{\parskip}{0.5cm}
\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}
\sloppy

\definecolor{darkgreen}{rgb}{0.0, 0.5, 0.0}
\lstset{
language=C++,
basicstyle=\footnotesize,
numbers=left,
numberstyle=\tiny,
numberfirstline=true,
numbersep=5pt,
keywordstyle=\color{blue}\bfseries,
commentstyle=\color{darkgreen},
stringstyle=\color{red},
showspaces=false,
showstringspaces=false,
captionpos=t,
breaklines=true,
breakatwhitespace=false,
extendedchars=true,
frame=tb,
title=\lstname,
}

\begin{document}
\begin{titlepage}

\begin{center}
   
Министерство науки и высшего образования Российской Федерации
{Федеральное государственное автономное образовательное учреждение высшего образования} \\
\textbf{"Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского" (ННГУ)} \\
\textbf{Институт информационных технологий, математики и механики}

\vspace{\fill}

\textbf{\LargeОтчет по лабораторной работе \\}
\textbf{\large\\ «Сортировка Хоара с четно-нечетным слиянием Бэтчера»}

\vspace{\fill}

\hfill\parbox{8cm}{
\hspace*{5cm}\hspace*{-5cm}\textbf{Выполнил:} \\ Студент группы 381708-1 \\ Коробейников Алексей Петрович \\ \\ \\
\hspace*{5cm}\hspace*{-5cm}\textbf{Проверил:}\\ Доцент кафедры МОСТ, \\ кандидат технических наук \\ Сысоев А. В.
\hbadness=20000
}

\vspace{\fill}

Нижний Новгород \\ 2020 г.
\end{center}

\end{titlepage}

% =============================================
% Оглавление
% =============================================
\setcounter{page}{2}
\setlength{\cftsecindent}{0em}
\setlength{\cftsubsecindent}{1.25em}
\setlength{\cftsubsubsecindent}{2.5em}
\setlength{\cftsubsubsecnumwidth}{1.25em}
\tableofcontents


\newpage
% =============================================
% Введение
% =============================================
\section*{Введение}
\addcontentsline{toc}{section}{Введение}
\par Сортировка Хаора (или быстрая сортировка quicksort) - алгоритм сортировки, разработанный английским информатиком Чарльзом Хоаром. Представляет собой один из самых быстрых и универсальных алгоритмов сортировки массивов: в среднем $O(n\log n)$ обменов при упорядочении n элементов.
\par Популярность данного алгоритма сортировки обусловленна его быстродействием в среднем случае по сравнению с его конкурентами (MergeSort), а также меньшим использованием дополнительной памяти. Тем не менее, некоторые минусы: большая ассимптотика худшего случая ($O(n^2)$), а также риск переполнения стека, заставляют использовать на практике гибриды данного алгоритма с другими алгоритмами сортировки (например: c HeapSort в Std).
\par Целью данной работы является реализация последовательной версии алгоритма сортировки Хоара, а также распараллеливание данного алгоритма с использованием четно-нечетного слияния Бетчера и разных технологий выполнения параллельных вычислений.


\newpage
% ===========================================
% 1. Постановка задачи
% ===========================================
\section*{1. Постановка задачи}
\addcontentsline{toc}{section}{1. Постановка задачи}
В рамках данных лабораторных работ ставится задача: реализовать алгоритм сортировки Хоара с четно-нечетным слиянием Бетчера с использованием различных технологий для выполнения параллельных вычислений.
\par Для решения данной задачи необходимо выполнить следующие пункты:
\begin{itemize}
\item изучить алгоритм сортировки Хоара и реализовать его последовательную версию;
\item рассмотреть в чем заключается четно-нечетное слияние Бетчера и написать параллельные реализации алгоритма Хоара с использованием данного слияния с помощью OpenMP, TBB и потоков из стандартной библиотеки языка C++ (\verb|std::thread|);
\item выполнить сравнение и сделать выводы об эффективности написанных реализаций;
\item проверить корректность работы алгоритма.
\end{itemize}


\newpage
% ===========================================
% 2. Описание алгоритма
% ===========================================
\section*{2. Описание алгоритма}
\addcontentsline{toc}{section}{2. Описание алгоритма}

\par Быстрая сортировка относится к алгоритмам "разделяй и властвуй".
Сам алгоритм можно записать в 3 шага:
\begin{enumerate}
\item Выбрать элемент из массива. Назовём его опорным. В качестве опорного элемента можно брать любой элемент сортируемого массива. Как правило за опорный элемент берут средний элемент, либо элемент, индекс которого выбрается генератором рандомных чисел.
\item Разбиение: перераспределение элементов в массиве таким образом, что элементы меньше опорного встают перед ним, а больше или равные после. Для реализации данного шага можно использовать разные виды разбиений, мы будем использовать разбиение Хоара. Оно заключается в следующем: идем по исходному массиву двумя индексами (с начала и с конца), как только нашлась пара элементов, где один больше опорного и стоит перед ним, а второй меньше и стоит после, то меняем эти элементы местами. Разбиение Хоара осуществляется, пока индексы не пересекуться.
\item Рекурсивно применить первые два шага к двум подмассивам слева и справа от опорного элемента. Рекурсия не применяется к массиву, в котором только один элемент или отсутствуют элементы.
\end{enumerate}
\par Для небольшой оптимизации алгоритма по используемой стековой памяти будем использовать прием, который называется "хвостовая элиминация". Суть данного приема в устранении одной ветви рекурсии: вместо того, чтобы после разделения массива вызывать рекурсивно процедуру разделения для обоих найденных подмассивов, рекурсивный вызов делается только для меньшего подмассива, а больший обрабатывается в цикле в пределах этого же вызова процедуры. С точки зрения эффективности в среднем случае разницы практически нет: накладные расходы на дополнительный рекурсивный вызов и на организацию сравнения длин подмассивов и цикла — примерно одного порядка. Зато глубина рекурсии ни при каких обстоятельствах не превысит $\log_2 n$, в то время как в стандартном алгоритме глубина рекурсии достигает $n$. Применение этого метода не спасёт от катастрофического падения производительности в худшем для алгоритма случае, но переполнения стека не будет.



\newpage
% ===========================================
% 3. Описание схемы распараллеливания
% ===========================================
\section*{3. Описание схемы распараллеливания}
\addcontentsline{toc}{section}{3. Описание схемы распараллеливания}
\par Для распараллеливания алгоритма сортировки будем делить исходный массив на N частей. Каждая отдельная часть будет сортироваться в отдельном потоке. То есть потоков будет столько же, сколько и частей массива - N.
\par После того, как части массива отсортированы по отдельности, мы можем приступить к этапу слияния. Для данного этапа будем использовать четно-нечетное слияние Бетчера, которое заключается в том, что два упорядоченных массива, которые необходимо слить, разделяются на чётные и нечётные элементы. Такое слияние может быть выполнено параллельно. Каждые две отдельные части массива будут сливаться с использованием двух потоков: первый поток будет сравнивать четные элементы, второй - нечетные. Чтобы массив стал окончательно отсортированным, достаточно сравнить пары элементов, стоящие на нечётной и чётной позициях. Первый и последний элементы массива проверять не надо, т.к. они являются минимальным и максимальным элементами массивов.
\par Чётно-нечётное слияние Бэтчера позволяет задействовать 2 потока
при слиянии двух упорядоченных массивов. В этом случае слияние n массивов могут выполнять n параллельных потоков. На следующем шаге слияние n/2 полученных массивов будут выполнять n/2 потоков и т.д. На последнем шаге два массива будут сливать 2 потока.

   


\newpage
% ===========================================
% 4. Описание программной реализации
% ===========================================
\section*{4. Описание программной реализации}
\addcontentsline{toc}{section}{4. Описание программной реализации}
\par В данном разделе приведены краткие описания схем параллельного выполнения для различных технологий параллельного программирования. Полный код можно найти в приложении.

\subsection*{4.1. Описание реализации с использованием OpenMP}
\addcontentsline{toc}{subsection}{4.1. Описание реализации с использованием OpenMP}
\par Для распараллеливания алгоритма при помощи технологии OpenMP использовалась директива препроцессора \verb|#pragma omp parallel for|. \\
Она позволяет разделить работу по сортировке массива на N частей. Каждая отдельная часть будет представлять собой новую итерацию цикла, которая будет выполняться в отдельном потоке. Для задания числа потоков будем использовать функцию \verb|omp_set_num_threads(num)| (перед параллельной областью). Таким образом, каждый из потоков будет сортировать часть массива длинной $\frac{n}{num}$.
\par После того как части массива упорядочены, будем осуществлять слияние. Для этого воспользуемся циклом while. В нем будем сливать каждые 2 части массива, которые еще не слиты, отдельными 2 потоками (слияние Бетчера). Число кусков массива, которые будут участвовать в слияние, на каждой итерации цикла уменьшается вдвое. Таким образом, признак остановки сортировки массива - оставшаяся для слияния одна часть массива (целый массив).
\subsection*{4.2. Описание реализации с использованием TBB}
\addcontentsline{toc}{subsection}{4.2. Описание реализации с использованием TBB}
\par Чтобы выполнить данный алгоритм параллельно с помощью TBB, будем использовать механизм логических задач \verb|tbb::task|. Каждая логическая задача содержит метод \verb|task::execute| в котором будут выполнятся вычисления.
\par Для нашего алгоритма бытсрой сортировки нам понадобится две задачи для слияния: EvenSplitter и OddSplitter - слияние четных и нечетных элементов. А также создадим общую задачу QuickParallelSorter, которая будет делать рекурсивные вызовы, разбивая исходный массив до тех пор, пока размер отдельной части не будет меньше установленной границы (граница зависит от числа потоков). Наконец, чтобы осуществлять последний этап слияния Бетчера (пробег по слитым массивам и сравнение пар элементов) параллельно, нам понадобиться использовать механизм распараллеливания циклов от TBB: \verb|tbb::parallel_for|. Данная функция принимает объект \verb|tbb::blocked_range|, задающий количество итераций цикла, а также объект класса-функтора. В качестве функтора мы реализуем SimpleComparator, который и будет выполнять финальный пробег по массиву с сравнением необходимых элементов.
\par Таким образом, мы получили следующий алгоритм:
\begin{enumerate}
    \item Задача QuickParallelSorter рекурсивно делит исходный массив на порции определенного размера, зависящего от числа потоков. Когда размер части становится меньше граничного значения, вызываем метод последоватьной сортироски Хоара для данной части массива и возвращаемся из рекурсии.
    \item После того как вызов подзадач на упорядочивание частей массивов завершен, мы можем приступить к слиянию: создаем и выполняем задачи: EvenSplitter и OddSplitter.
    \item Наконец, для окончательной сортировки слитых частей вызываем метод \verb|tbb::parallel_for|, передав ему границы обрабатываемой части массива и объект класса SimpleComparator. После того как над частями массива выполнены шаги 2 и 3, передаем управление вверх по рекурсии.
\end{enumerate}
\par Для запуска выполнения задач и ожидания их завершения используются методы: \verb|spawn| и \verb|spawn_and_wait_for_all|
\subsection*{4.3. Описание реализации с использованием std::thread}
\addcontentsline{toc}{subsection}{4.3. Описание реализации с использованием std::thread}
\par Схема распараллеливания с использованием технологии \verb|std::thread| будет аналогична технологии TBB. Только теперь необходимый функционал будет содержаться не в классах, наследуемых от логичекских задач TBB, а просто в классах-функторах. Для создания потока используем конструктор \verb|std::thread|, в который будем передавать объект класса функтора. А для ожидания завершения потока используем метод \verb|join| для каждого вызванного потока.


\newpage
% =============================================
% 5. Результаты экспериментов и описание подтверждения корректности
% =============================================
\section*{5. Результаты экспериментов и описание подтверждения корректности}
\addcontentsline{toc}{section}{5. Результаты экспериментов и описание подтверждения корректности}
\par Конфигурация системы:
\begin{itemize}
\item Процессор: Intel Core i5-8300H @ 2.30GHz
\item Оперативная память: 8 GB
\item Операционная система: Windows 10
\item Число ядер: 8 ядер
\end{itemize}
\par Результаты вычислительных экспериментов для массива с $size = 10^8$ представлены в таблице.

\begin{table}[!h]
\caption{Результаты вычислительных экспериментов}
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
\multirow{3}{*}
	{\begin{tabular}[c]{@{}c@{}}Кол-во\\ потоков\end{tabular}} & 
\multirow{2}{*}
	{\begin{tabular}[c]{@{}c@{}}Последовательный\\ алгоритм\end{tabular}} & 
\multicolumn{6}{c|}
	{Параллельный алгоритм}	\\ 
	\cline{3-8} & & 
	\multicolumn{2}{c|}{OpenMP} & 
	\multicolumn{2}{c|}{TBB} & 
	\multicolumn{2}{c|}{std::thread} 
	\\ \cline{2-8}
	& t, с	    & t, с & speedup		& t, с & speedup		& t, с & speedup		\\ \hline
2   & 5.35    & 3,147 & 1.7       	& 3,147 & 1.7        	& 3,34375 & 1.6          \\ \hline
4   & 5.35    & 2.378 & 2.25       	& 2.356 & 2.27         	& 2.52  & 2.12         \\ \hline
8   & 5.35    & 2.257 & 2.37          & 2.262 & 2.365         & 2.465 & 2.17        \\ \hline
\end{tabular}
\end{table}
\par По результатам проделанных экспериментов можно сделать следующие выводы:
\begin{enumerate}
    \item На 2 потоках видно, что алгоритм достаточно неплохо параллелится и дает ускорение порядка 1.7 отсносительно последовательной версии
    \item Для всех трех технологий наблюдается быстрый спад прироста ускорения с ростом потоков (ускорение на 4 и 8 потоках уже практически одинаковое). Это обусловленно большими накладными расходами на создание и обслуживание потоков для данной задачи (создается много потоков для четного и нечетного слияния).
    \item Реализации задачи с использованием TBB и std::thread практически одинаковая, но TBB показывает более высокий результат. Это говорит о том, что в библиотеке TBB лучшего организована работа планировщика потоков.
    \item Лучшего результата удалось достичь с помощью библиотек OpenMP и TBB.
\end{enumerate}
\par Для подтверждения корректности в программе реализован набор тестов, разработанных при помощи библиотеки для модульного тестирования Google C++ Testing Framework. Проверяются случаи сортировки массивов с использованием разного количества потоков, а также проводится тестирование на различных размерах исходного сортируемого массива. Результат работы алгоритма сортировки Хоара с четно-нечетным слиянием Бетчера проверяется с помощью функции \verb|std::is_sorted|, которая смотрит упорядочены ли элементы в массиве.
\par Успешное прохождение всех тестов демонстрирует способность программы корректно работать при различных исходных условиях. 



\newpage
% =============================================
% Заключение
% =============================================
\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}

\par В процессе выполнения данных лабораторных работ была реализована последовательная версия сортировки Хоара, рассмотрен принцип четно-нечетного слияния Бетчера, с помощью которого на основе различных технологий реализована параллельная версия сортировки Хоара. Также была проведена оценка на эффективность работы разработанных программ, которая показала, что при увеличении числа потоков не получается достичь соответсвующего ускорения по причине больших накладных расходов на создание потоков.
\par В результате самыми эффективными реализациями оказались те, которые написаны с помощью технологий OpenMP и TBB. А проведенное тестирование показало корректность работы программ.

\newpage
% =============================================
% Список литературы
% =============================================
\section*{Список литературы}
\addcontentsline{toc}{section}{Список литературы}
\begin{enumerate}
\item Сысоев А.В., Мееров И.Б., Сиднев А.А. Средства разработки параллельных программ для систем с общей памятью. Библиотека Intel Threading Building Blocks. Учебно-методические материалы по программе повышения квалификации «Технологии высокопроизводительных вычислений для обеспечения учебного процесса и научных исследований». Нижний Новгород, 2007, 86 с.
\item Guide into OpenMP: Easy multithreading programming for C++. URL: \url{https://bisqwit.iki.fi/story/howto/openmp/}
\item Intel Threading Building Blocks User Guide. URL: \url{https://www.threadingbuildingblocks.org/docs/help/tbb_userguide/parallel_for.html}
\item Оптимизация вычислительно трудоемкого программного модуля для архитектуры Intel Xeon Phi. Линейные сортировки. URL: \url{http://hpc-education.unn.ru/files/courses/XeonPhi/Lab07.pdf}
\end{enumerate}

\newpage
% =============================================
% Приложение
% =============================================
\section*{Приложение}
\addcontentsline{toc}{section}{Приложение}

\subsection*{Исходный код}
\addcontentsline{toc}{subsection}{Исходный код}

\subsubsection*{Лабораторная работа №1. Последовательная версия}
\addcontentsline{toc}{subsubsection}{Лабораторная работа №1. Последовательная версия}
\lstinputlisting[language=C++, caption=Последовательная версия. Заголовочный файл]{../../../../modules/task_1/korobeinikov_a_quick_sort/quick_sort.h}
\lstinputlisting[language=C++, caption=Последовательная версия. Файл с реализацией]{../../../../modules/task_1/korobeinikov_a_quick_sort/quick_sort.cpp}
\lstinputlisting[language=C++, caption=Последовательная версия. Файл с тестами]{../../../../modules/task_1/korobeinikov_a_quick_sort/main.cpp}

\newpage
\subsubsection*{Лабораторная работа №2. Параллельная версия с использованием OpenMP}
\addcontentsline{toc}{subsubsection}{Лабораторная работа №2. Параллельная версия с использованием OpenMP}
\lstinputlisting[language=C++, caption=Последовательная версия. Заголовочный файл]{../../../../modules/task_2/korobeinikov_a_quick_sort/quick_sort.h}
\lstinputlisting[language=C++, caption=Последовательная версия. Файл с реализацией]{../../../../modules/task_2/korobeinikov_a_quick_sort/quick_sort.cpp}
\lstinputlisting[language=C++, caption=Последовательная версия. Файл с тестами]{../../../../modules/task_2/korobeinikov_a_quick_sort/main.cpp}

\newpage
\subsubsection*{Лабораторная работа №3. Параллельная версия с использованием TBB}
\addcontentsline{toc}{subsubsection}{Лабораторная работа №3. Параллельная версия с использованием TBB}
\lstinputlisting[language=C++, caption=Последовательная версия. Заголовочный файл]{../../../../modules/task_3/korobeinikov_a_quick_sort/quick_sort.h}
\lstinputlisting[language=C++, caption=Последовательная версия. Файл с реализацией]{../../../../modules/task_3/korobeinikov_a_quick_sort/quick_sort.cpp}
\lstinputlisting[language=C++, caption=Последовательная версия. Файл с тестами]{../../../../modules/task_3/korobeinikov_a_quick_sort/main.cpp}

\newpage
\subsubsection*{Лабораторная работа №4. Параллельная версия с использованием std::thread}
\addcontentsline{toc}{subsubsection}{Лабораторная работа №4. Параллельная версия с использованием std::thread}
\lstinputlisting[language=C++, caption=Последовательная версия. Заголовочный файл]{../../../../modules/task_4/korobeinikov_a_quick_sort/quick_sort.h}
\lstinputlisting[language=C++, caption=Последовательная версия. Файл с реализацией]{../../../../modules/task_4/korobeinikov_a_quick_sort/quick_sort.cpp}
\lstinputlisting[language=C++, caption=Последовательная версия. Файл с тестами]{../../../../modules/task_4/korobeinikov_a_quick_sort/main.cpp}

\end{document}