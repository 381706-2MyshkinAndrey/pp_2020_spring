\documentclass{report}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{luainputenc}
\usepackage[english, russian]{babel}
\usepackage[pdftex]{hyperref}
\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{enumitem}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{indentfirst}

\geometry{a4paper,top=2cm,bottom=3cm,left=2cm,right=1.5cm}
\setlength{\parskip}{0.5cm}
\setlist{nolistsep, itemsep=0.3cm,parsep=0pt}

\lstset{language=C++,
		basicstyle=\footnotesize,
		keywordstyle=\color{blue}\ttfamily,
		stringstyle=\color{red}\ttfamily,
		commentstyle=\color{green}\ttfamily,
		morecomment=[l][\color{magenta}]{\#}, 
		tabsize=4,
		breaklines=true,
  		breakatwhitespace=true,
  		title=\lstname,       
}

\begin{document}

\begin{titlepage}

\begin{center}
Министерство науки и высшего образования Российской Федерации
\end{center}

\begin{center}
Федеральное государственное автономное образовательное учреждение высшего образования \\
Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского
\end{center}

\begin{center}
Институт информационных технологий, математики и механики
\end{center}

\vspace{3em}

\begin{center}
\textbf{\Large Отчет по лабораторной работе} \\
\end{center}
\begin{center}
\textbf{\Large «Умножение разреженных матриц. Элементы комплексного типа. Формат хранения -- строковый (CCS)»} \\
\end{center}

\vspace{4em}

\newbox{\lbox}
\savebox{\lbox}{\hbox{text}}
\newlength{\maxl}
\setlength{\maxl}{\wd\lbox}
\hfill\parbox{7cm}{
\hspace*{5cm}\hspace*{-5cm}\textbf{Выполнил:} \\ студент группы 381706-1 \\ Карин Т. А.\\
\\
\hspace*{5cm}\hspace*{-5cm}\textbf{Проверил:}\\ доцент кафедры МОСТ, \\ кандидат технических наук \\ Сысоев А. В.
}

\vspace{\fill}

\begin{center} Нижний Новгород \\ 2020 \end{center}

\end{titlepage}

\setcounter{page}{2}

\tableofcontents
\newpage

\section*{Введение}
\addcontentsline{toc}{section}{Введение}
Достаточно часто встречаются такие матрицы, в которых важными являютя лишь некоторые элементы. Матрицы, в которых большинство элементов являются нулевыми, называются разреженными. Хранить значения всех элементов таких матриц не рационально. Для экономии памяти их принято записывать в координатном, строковом (CRS) или столбцовом (CCS) форматах. В данной работе будет рассмотрен только столбцовый формат.
\par Для хранения матрицы в столбцовом формате необходимы 3 вектора:
\begin{description}
	\item [Value] Хранит непосредственно ненулевые значения матрицы. Они располагаются последовательно: упорядочены по номеру столбца, а затем по номеру строки. Каждый элемент представляет из себя комплексное число.
	\item [Row] Каждый элемент хранит номер строки, в которой расположен соответствующий ему элемент вектора value.
	\item [Col] Хранит номера элементов вектора value, с которых начинаются соответствующие строки матрицы. В отличие от предыдущих векторов, размер Col зависит от размера матрицы, а не от количества ненулевых элементов в ней.
\end{description}
\par Одной из основных операций с матрицами является умножение. Так как способ хранения матрицы отличается от обычного, то и алгоритм умножения тоже немного видоизменён. Целью работы является написание алгоритма умножения разреженных матриц, хранящихся в столбцовом формате, и примененение к нему различных методов распараллеливания.
\newpage



\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}
В ходе работы необходимо выполнить следующие задачи:
\begin {itemize}
	\item Реализовать последовательный алгоритм умножения разреженных матриц форамата CCS;
	\item Реализовать параллельный алгоритм умножения разреженных матриц с помощью технологии OpenMP;
	\item Написать параллельный алгоритм умножения разреженных матриц с помощью библиотеки TBB;
	\item Написать параллельный алгоритм умножения разреженных матриц, используя std::thread;
	\item Проверить корректность и эффективность полученных алгоритмов.
\end {itemize}
\newpage



\section*{Метод решения}
\addcontentsline{toc}{section}{Метод решения}
Пусть $A$ и $B$ разреженные матрицы. Матрица $C$, получаемая в результате умножения $A\cdot B = C$, тоже является разреженной и записывается в столбцовом формате. В привычном виде каждый элемент матрицы $C$, находящийся в $i$ строке $j$ столбце, представляет из себя скалярное умножение $i$ строки матрицы $A$ и $j$ столбца матрицы $B$. При этом матрицы хранятся в столбцовом формате и нацелены на использование именно столбцов, а не строк. В связи с этим, матрицу $A$ рациональнее один раз транспонировать, чем выделять из неё отдельную строку на каждой итерации.
\par Теперь каждый $i$ столбец матрицы $C$ получается с помощью поочерёдного скалярного умножения $i$ столбца матрицы $B$ и всех столбцов транспонированной матрицы $A^T$. Таким образом, алгоритм умножения представляет из себя двойной цикл. Внутренний цикл пробегает все значения столбцов транспонированной матрицы $A^T$. Внешний цикл пробегает все значения столбцов матрицы $B$. На каждой итерации вычисляется значние скалярного произедения соответствующих векторов. Если полученное значение ненулевое, то оно записывается в матрицу $C$. При этом в вектор Row записывается соответствующий номер столбца матрицы $A^T$. После каждой итерации внешнего цикла размер вектора Value записывается в ячейку вектора Col, соответствующую номеру столбца $B$.
\newpage


\section*{Схема распараллеливания}
\addcontentsline{toc}{section}{Схема распараллеливания}
Расспараллеливание алгоритма умножения основано на разделении внешнего цикла последовательного алгоритма. Вычисления для столбцов матрицы $B$ могут производиться независимо. Для каждой непрерывной группы столбцов матрицы $B$, вычисления над которыми будут выполняться последовательно, создаются локальные векторы Value и Row. Элементы вектора Col в параллельной версии хранят не номер элемента вектора Value, с которого начинается строка, а количество элементов в этой строке. В таком виде вектор Col может заполняться бесконфликтно. После заполнения всех векторов, локальные векторы Value и Row сливаются в глобальные, а в векторе Col выполняется операция добавления каждому элементу суммы всех предыдущих. В результате, вектор Col хранит номера элементов, с которых начинаются соответствующие строки матрицы $C$.
\newpage



\section*{Описание программной реализации}
\addcontentsline{toc}{section}{Описание программной реализации}

\subsection*{OpenMP}
\addcontentsline{toc}{subsection}{OpenMP}
В реализации OpenMP версии используется директива \verb|#pragma omp for schedule(static)| для распараллеливания основного цикла. Параметр chank не задан, чтобы столбцы распределялись последовательно и непрерывно. В этом случае локальные векторы Value и Row создаются по одному для каждого потока, а не столбца матрицы $B$. После заполнения векторов используется директива \verb|#pragma omp barrier| для синхронизации. Затем необходимо сложить результаты вектора Col, чтобы он хранил не количества элементов в строках, а номера элементов, с которых строки начинаются. Для этого используется дирректива \verb|#pragma omp single|. После получения вектора Col создаются глобальные векторы Value и Row, размер которых определяется последним элементом вектора Col. Затем потоки параллельно заполняет соответствующие им участки глобальных векторов.

\subsection*{TBB}
\addcontentsline{toc}{subsection}{TBB}
В реализации TBB версии локальные векторы создаются для каждой строки матрицы $C$. Для распараллеливания используется функция \verb|tbb::parallel_for(params)|, принимающая на вход итерационное пространство и функтор. Итерационное пространство в нашем случае одномерное, первый элемент равен нулю, последний -- количеству столбцов матрицы $B$. В функтор передаются указатели на матрицы $A$ и $B$, на локальные векторы Value и Row, и на вектор Col. В функторе прописан основной двойной цикл, заполняющий локальные векторы Value и Row, а также соответствующую часть вектора Col. Границы внешнего цикла определяются автоматически библиотекой TBB. После заполнения локальных векторов, они последовательно сливаются в глобальные, а к каждому элементу вектора Col добавляется сумма предыдущих.

\subsection*{std::threads}
\addcontentsline{toc}{subsection}{std::threads}
Основной двойной цикл программы, как и в TBB версии, прописан в отдельной функции, которую выполняют все созданные потоки. Столбцы матрицы $B$, как и в OpenMP версии, распределяются равномерно и непрерывно между всеми потоками. Для каждого потока создаются локальные векторы Value и Row, доступ к которым осуществляется через указатели. После заполнения векторов они последовательно сливаются в глобальные, а над вектором Col проделывается операция добавления к каждому элементу суммы предыдущих.
\newpage



\section*{Подтверждение корректности}
\addcontentsline{toc}{section}{Подтверждение корректности}
Для подтверждения корректности функций был реализован набор тестов с использованием библиотеки Google C++ Testing Framework. Тесты нацелены на проверку следующих функций:
\begin {itemize}
	\item Создание разреженной матрицы с заданным числом ненулевых случайных элементов, расположенных случайным образом.
	\item Транспонирование разреженной матрицы.
	\item Скалярное произведение векторов.
	\item Последовательное умножение разреженных матриц.
	\item Параллельное умножение разреженных матриц. Результат сверяется с результатом последовательного алгоритма с теми же исходными данными.
\end {itemize}
\newpage




\section*{Результаты экспериментов}
\addcontentsline{toc}{section}{Результаты экспериментов}
Для проведения экспериментов использовалась следующая тестовая инфраструктура:
\begin {description}
	\item [Процессор] Intel Core i5-8250U, 1600 MHz, 4 ядра, 8 потоков
	\item [Оперативная память] 11 941 МБ, DDR4, 2400 MHz
	\item [Операционная система] Microsoft Windows 10 Home
\end {description}
\par Во всех экспериментах используются квадратные матрицы, при этом количество ненулевых элементов разреженных матриц совпадает с размерностью матрицы. Параллельные алгоритмы выполняются на 4 потоках.
Результаты экспериментов приведены в таблице \ref{results}.
\begin {table}[h]
\caption {Результаты экспериментов}
\label{results}
\begin {tabular}{|p{3cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|}
	\hline
	Размер и количество ненулевых элементов & Пос\-ле\-до\-ва\-тель\-ный & \multicolumn {2} {|c|}{OpenMP} & \multicolumn {2} {|c|}{TBB} & \multicolumn {2} {|c|}{std::thread} \\ \cline{3-8}
	& & время (сек) & ус\-ко\-ре\-ние & время (сек) & ус\-ко\-ре\-ние & время (сек) & ус\-ко\-ре\-ние \\ \hline
	500 &  0.0034 & 0.001 & 3.4 & 0.0018 & 1.8 & 0.0039 & 0.87 \\ \hline
	1000 & 0.0092 & 0.0047 & 1.95 & 0.004 & 2.3 & 0.0038 & 2.4 \\ \hline
	5000 & 0.195 & 0.0846 & 2.3 & 0.0715 & 2.7 & 0.0813 & 2.4 \\ \hline
	10 000 & 0.6509 & 0.2050 & 3.17 & 0.2366 & 2.75 & 0.2537 & 2.56 \\ \hline
	30 000 & 5.9713 & 2.4581 & 2.4 & 2.0584 & 2.9 & 2.0686 & 2.88 \\ \hline
	70 000 & 32.1795 & 13.3678 & 2.4 & 12.0807 & 2.6 & 11.2551 & 2.8 \\ \hline
	100 000 & 61.1083 & 26.7488 & 2.28 & 22.9834 & 2.65 & 25.9582 & 2.35 \\ \hline
\end {tabular}
\end {table}
\par Из результатов видно, что все параллельные алгоритмы имеют примерно одинаковую эффективность и позволяют ускорить операцию умножения в 2,5 раза. Но всё же результат работы TBB чуть лучше, чем OpenMP и std::tread. 
\newpage




\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
В ходе работы были изучены основы работы с разреженными матрицами. Был реализован последовательный алгоритм умножения разреженных матриц. Также были написаны параллельные варианты данного алгоритма с помощью различных технологий: OpenMP, TBB, std::thread.
\par Для проверки работоспособности основных и вспомогательных функций был реализован набор тестов с использованием Google C++ Testing Framework. Реализованные программы успешно проходят данные тесты.
\par Также были проведены эксперименты для различных входных параметров.
\newpage



\section*{Список литературы}
\addcontentsline{toc}{section}{Список литературы}
\begin {enumerate}
\item Intuit [Электронный ресурс] // URL:https://www.intuit.ru/studies/courses/4447/983/lecture/14931?page=5 (дата обращения: 19.06.2020)
\item Wikipedia [Электронный ресурс] // URL: https://ru.wikipedia.org/wiki/\verb|Разреженная_матрица| (дата обращения: 18.06.2020)

\end{enumerate}
\newpage


\section*{Приложение}
\subsection*{Последовательный алгоритм}
\lstinputlisting[language=C++]{../../../../modules/task_1/karin_t_sparce_matrix_complex_CCS/sparce_matrix.h}
\lstinputlisting[language=C++]{../../../../modules/task_1/karin_t_sparce_matrix_complex_CCS/sparce_matrix.cpp}
\lstinputlisting[language=C++]{../../../../modules/task_1/karin_t_sparce_matrix_complex_CCS/main.cpp}

\subsection*{OpenMP}
\lstinputlisting[language=C++]{../../../../modules/task_2/karin_t_sparce_matrix_complex_CCS/sparce_matrix.h}
\lstinputlisting[language=C++]{../../../../modules/task_2/karin_t_sparce_matrix_complex_CCS/sparce_matrix.cpp}
\lstinputlisting[language=C++]{../../../../modules/task_2/karin_t_sparce_matrix_complex_CCS/main.cpp}

\subsection*{TBB}
\lstinputlisting[language=C++]{../../../../modules/task_3/karin_t_sparce_matrix_complex_CCS/sparce_matrix.h}
\lstinputlisting[language=C++]{../../../../modules/task_3/karin_t_sparce_matrix_complex_CCS/sparce_matrix.cpp}
\lstinputlisting[language=C++]{../../../../modules/task_3/karin_t_sparce_matrix_complex_CCS/main.cpp}

\subsection*{std::thread}
\lstinputlisting[language=C++]{../../../../modules/task_4/karin_t_sparce_matrix_complex_CCS/sparce_matrix.h}
\lstinputlisting[language=C++]{../../../../modules/task_4/karin_t_sparce_matrix_complex_CCS/sparce_matrix.cpp}
\lstinputlisting[language=C++]{../../../../modules/task_4/karin_t_sparce_matrix_complex_CCS/main.cpp}

\end {document}